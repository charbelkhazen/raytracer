I have built a ray tracer and I am facing a single issue for which I could not find the root cause

here is my issue:

whenever the sphere center's x and y coordinates diverge from 0 the sphere loses a the sphere format and looks like an egg (an oval)

below are : the input (minirt.rt file which user inputs to program) and some functions related to the sphere's drawing (Pasted main concerned implementation + interfaces used)

Analyzing these function are you able to infer the root cause of this issue (note: the sphere is a perfect sphere when x and y are set to be 0 but becomes oval - egg like as soon as x and y diverge ) (and the more they diverge, the more, they are oval)


NOTE: IF YOU ARE NOT ABLE TO INFER THE ROOT CAUSE , LET ME KNOW SO I CAN AUGMENT YOU WITH MORE CONTEXT

here is my minirt.rt file which I input:


A 0.7 1,1,1
C 0,0,0 0,0,-1 140
L 8,15,-1 1.0 1,1,1
sp 0,0,-5 2 1,0,0
sp 5,0,-5 2 1,0,0

as you can see it has two spheres (the first is correctly outputed by the program , the other not)

main implementation:
#include "parser.h"
#include "scene.h"
#include "ui.h"
#include "error.h"
#include "render.h"
#include <fcntl.h>

int main(void)
{
	int	file_descriptor;
	t_scene scene;
	ui_mlxParams_t	mlx_params;

	file_descriptor  = open("minirt.rt", O_RDONLY); //TODO:handle failure in open 
	//TODO: HANDLE FD CLOSURE!!!!!!!

	//TODO: parseProgram fils scene -> let scene be its first parameter 
	if (pars_parseProgram(file_descriptor, &scene))
		return (err_msgReturnOne("Wrong Format in .rt file"));
	if (ui_initMlx(&mlx_params, scene.cam.img.img_ratio, scene.cam.img.img_width, "MiniRT"))
        	return err_msgReturnOne("MLX init failed");
	render_logicToMlx(&mlx_params, &scene);

	ui_mlxRender(&mlx_params);

	return (0);
}

parser.c (parser implementation) 

#include <string.h> // FORBIDDEN FUNCTIONMEMESET - REMOVE LATER


#include "parser.h"
#include "stdlib.h"
#include "error.h"
#include <stdlib.h>
#include <unistd.h>
#include "vector.h"
#include "light.h"
#include "ambientlight.h"
#include "viewer.h"
#include "object.h"
#include "sphere.h"
#include "material.h"
#include "get_next_line.h"

void	pars_skipWhiteSpace(char **ptr_buf)
{
	std_assert(ptr_buf && *ptr_buf);

	while (**ptr_buf && std_isWhiteSpace(**ptr_buf))
		(*ptr_buf) ++;
}

//first letter alone does reveal the type
static int pars_associateTypeToLetter(t_cmd_type *type, int first_char)
{
	if (first_char == 'A')
		*type = AMBIENT_CMD;
	else if (first_char == 'L')
		*type = LIGHT_CMD;
	else if (first_char == 'C')
		*type = CAMERA_CMD;
	else if (first_char == 's')
		*type = SPHERE_CMD;
	else if (first_char == 'c')
		*type = CYLINDER_CMD;
	else if (first_char == 'p')
		*type = PLANE_CMD;
	else
		return (1); //NOTE: SHOULD NEVER HAPPEN.
	return (0);
}

int	pars_consumeType(t_cmd_type *type, char **ptr_buf)
{
	char	first_char;
	char	second_char;	

	std_assert(ptr_buf && *ptr_buf);

	first_char = **ptr_buf;

	//need to init second char anyways bcz of flags
	second_char = 0;
	if (first_char)
		second_char = *((*ptr_buf) + 1);

	if (( first_char == 's' && second_char == 'p') || (first_char == 'p' && second_char == 'l') || (first_char == 'c' && second_char == 'y'))
	    (*ptr_buf) += 2;
	else if (first_char == 'A' || first_char == 'C' || first_char == 'L')
	    (*ptr_buf) ++;
	else
	    return (1);

	//fill type
	if (pars_associateTypeToLetter(type, first_char))
		return (1);

	return (0);
}

int	pars_consumeNumber(double *num, char **buf)
{
	int	nbytes_consumed;

	std_assert(num && buf && *buf); //review this, maybe useless

	nbytes_consumed = 0;

	nbytes_consumed = std_atod(num, *buf);

	if (!nbytes_consumed)
		return (1);

	while (nbytes_consumed--)
		(*buf)++;

	return (0);
}

int	pars_consumeInteger(int *num, char **buf)
{
	int	nbytes_consumed;

	std_assert(num && buf && *buf); //review this, maybe useless

	nbytes_consumed = 0;

	nbytes_consumed = std_atoi(num, *buf);

	if (!nbytes_consumed)
		return (1);

	while (nbytes_consumed--)
		(*buf)++;

	return (0);
}

int	pars_consumeComma(char **buf)
{
	std_assert(buf && *buf); // may be useless

	if (**buf != ',')
		return (1);
	(*buf)++;

	return (0);
}
//TODO : CONTAINS UNDERLYING ASSUMPTIONS THAT MAY CHANGE
// 1 - ASSUMES USER WRITES M or m for metallix and matte -> you can choose later to let user write the whole material type rather than first letter
// 2 - Assumes onlyu matte and Material
int	pars_consumeMaterial(material_type *mat_type, char **buf)
{
	std_assert(buf && *buf); // may be useless

	if (!(**buf == 'm')) //TODO: ADD || **buf == 'M' , 'P' for plastic etc..
		return (1);
	if (**buf == 'm')
		*mat_type = MATTE_TYPE;
	else
		return (1);

	//else if (**buf == 'M')
	//*mat_type = METALLIC_TYPE;  //TODO: add mettalic and other textures 

	(*buf)++;
	return (0);
}

int	pars_consume3Numbers(t_vec *vector, char **buf)
{
	double	x;
	double	y;
	double	z;

	if (pars_consumeNumber(&x, buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeComma(buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeNumber(&y, buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeComma(buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeNumber(&z, buf))
		return (1);

	vec_fillVec(vector, x, y, z);

	return (0);
}

int	pars_consume3Integers(t_vec *vector, char **buf)
{
	int	x;
	int	y;
	int	z;

	if (pars_consumeInteger(&x, buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeComma(buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeInteger(&y, buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeComma(buf))
		return (1);
	pars_skipWhiteSpace(buf);
	if (pars_consumeInteger(&z, buf))
		return (1);

	vec_fillVec(vector, x, y, z);

	return (0);
}
int	pars_consumeMandatoryWhiteSpace(char **buf)
{
	if (!**buf || !std_isWhiteSpace(**buf))
		return (1);
	pars_skipWhiteSpace(buf);
	return (0);
}

int	pars_checkColorRange(t_vec color)
{
	double	x;
	double	y;
	double	z;

	x = color.x;
	y = color.y;
	z =  color.z;

	if (x < 0.0 || x > 255.0 || y < 0.0 || y > 255.0 || z < 0.0 || z > 255.0)
		return (1);
	return (0);
}

int	pars_checkUnitIntervalRange(double num)
{
	if (num < 0.0 || num > 1.0)
		return (1);
	return (0);
}

int	pars_parseLight(t_light *light, char *buf)
{
	std_assert(buf != 0);

	pars_skipWhiteSpace(&buf);
	if(pars_consume3Numbers(&light->src, &buf))
		return (1);
	if(pars_consumeMandatoryWhiteSpace(&buf))
		return (1);
	if(pars_consumeNumber(&light->bright, &buf))
		return (1);
	if(pars_checkUnitIntervalRange(light->bright))
		return (1);

	pars_skipWhiteSpace(&buf);

	if (*buf != '\n')
	{
		if(pars_consume3Integers(&light->color, &buf))
			return (1);
		if(pars_checkColorRange(light->color))
			return (1);
	}
	if (*buf != '\n')
		return (1);
	return (0);
}

int	pars_parseAmbient(t_ambientLight *ambient, char *buf)
{
	std_assert(buf != 0);

	pars_skipWhiteSpace(&buf);

	if(pars_consumeNumber(&ambient->ratio, &buf))
		return (1);
	if(pars_checkUnitIntervalRange(ambient->ratio))
		return (1);

	if(pars_consumeMandatoryWhiteSpace(&buf))
		return (1);

	if(pars_consume3Integers(&ambient->color, &buf))
		return (1);
	if(pars_checkColorRange(ambient->color))
		return (1);

	pars_skipWhiteSpace(&buf);

	if (*buf != '\n')
		return (1);

	return (0);
}

int	pars_parseCamera(t_viewer *view, char *buf)
{
	t_vec	lookfrom;
	t_vec	orientation_vector;
	double	hfov; 

	std_assert(buf != 0);

	//parsing and consuming
	pars_skipWhiteSpace(&buf);
	// see those as ordered steps in parsing. and if a step fails -> returns (1) -> func returns (1). I wrote it in one line for compactness
	if (pars_consume3Numbers(&lookfrom, &buf) || pars_consumeMandatoryWhiteSpace(&buf) 
		|| pars_consume3Numbers(&orientation_vector, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consumeNumber(&hfov, &buf))
		return (1);
	pars_skipWhiteSpace(&buf);
	if (*buf != '\n')
		return (1);

	//check if consumed match logic
	if (!std_cmpDoubles(vec_vectorLen(&orientation_vector), 1)
		|| (hfov < 0 || hfov > 180.0))
		return (1);
	
	viewer_defaultFill(view, lookfrom, hfov, orientation_vector);
	return (0);
}

// fills material given that mat.type is filled by the corresponding type
// I assume all materials have  only a single element which is an int
// in matte, this single element is .onoff
// I choose to fill it with 0
static int pars_fillMaterial(t_mat *mat)
{
	if (mat->type == MATTE_TYPE)
		mat_fillMatte(mat, 0);
	//TODO:implement else if for all other materials
	else
		return (1); // should never fall here
	return (0);
}

//fills an OBJECT not a sphere
//returns 1 on err
int	pars_parseSphere(t_obj *obj, char *buf)
{
	t_vec	center;
	t_vec	color;
	double	diameter;
	t_shape shape;
	t_mat	mat;

	std_assert(buf != 0);

	//default material is matte, if user inputs another then change (simulate default arg)
	mat.type = MATTE_TYPE;

	//parsing and consuming
	pars_skipWhiteSpace(&buf);
	// see those as ordered steps in parsing. and if a step fails -> returns (1) -> func returns (1). I wrote it in one line for compactness
	if (pars_consume3Numbers(&center, &buf) || pars_consumeMandatoryWhiteSpace(&buf) 
		|| pars_consumeNumber(&diameter, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consume3Integers(&color, &buf))
		return (1);
	pars_skipWhiteSpace(&buf);
	//optional material : 'm' : matte , 'M' : metallic 
	//see those as ordered sequence
	if (*buf != '\n')
	{
		if (pars_consumeMaterial(&mat.type, &buf)) 
			return (1);
		pars_skipWhiteSpace(&buf);
	}
	if (*buf != '\n')
		return (1);

	//check if consumed match logic
	if (pars_checkColorRange(color) || diameter < 0)
		return (1);

	//now I have validated : center, diameter, materialtype, color
	
	//we now fill
	shape_fillSphere(&shape, center, diameter / 2.0);
	//assumes material type has been added to mat
	pars_fillMaterial(&mat);
	obj_fillObj(obj, shape, mat, color);
	return (0);
}

int	pars_parseCylinder(t_obj *obj, char *buf)
{
	t_vec	center;
	t_vec	color;
	t_vec	normalized_axis;
	double	diameter;
	double	height;
	t_shape shape;
	t_mat	mat;

	std_assert(buf != 0);

	//default material is matte, if user inputs another then change (simulate default arg)
	mat.type = MATTE_TYPE;

	//parsing and consuming
	pars_skipWhiteSpace(&buf);
	// see those as ordered steps in parsing. and if a step fails -> returns (1) -> func returns (1). I wrote it in one line for compactness
	if (pars_consume3Numbers(&center, &buf) || pars_consumeMandatoryWhiteSpace(&buf) 
		|| pars_consume3Numbers(&normalized_axis, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consumeNumber(&diameter, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consumeNumber(&height, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consume3Integers(&color, &buf))
		return (1);
	pars_skipWhiteSpace(&buf);
	//optional material : 'm' : matte , 'M' : metallic 
	//see those as ordered sequence
	if (*buf != '\n')
	{
		if (pars_consumeMaterial(&mat.type, &buf)) 
			return (1);
		pars_skipWhiteSpace(&buf);
	}
	if (*buf != '\n')
		return (1);

	//check if consumed match logic
	if (!std_cmpDoubles(vec_vectorLen(&normalized_axis), 1) || pars_checkColorRange(color) || diameter < 0 || height < 0)
		return (1);
	
	//now I have validated : center, diameter, materialtype, color
	
	//we now fill
	shape_fillCylinder(&shape, center, normalized_axis, color, diameter, height);
	//assumes material type has been added to mat
	pars_fillMaterial(&mat);
	obj_fillObj(obj, shape, mat, color);
	return (0);
}

int	pars_parsePlane(t_obj *obj, char *buf)
{
	t_vec	point;
	t_vec	color;
	t_vec	normalized_normal;
	t_shape shape;
	t_mat	mat;

	std_assert(buf != 0);

	//default material is matte, if user inputs another then change (simulate default arg)
	mat.type = MATTE_TYPE;

	//parsing and consuming
	pars_skipWhiteSpace(&buf);
	// see those as ordered steps in parsing. and if a step fails -> returns (1) -> func returns (1). I wrote it in one line for compactness
	if (pars_consume3Numbers(&point, &buf) || pars_consumeMandatoryWhiteSpace(&buf) 
		|| pars_consume3Numbers(&normalized_normal, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consume3Integers(&color, &buf))
		return (1);
	pars_skipWhiteSpace(&buf);
	//optional material : 'm' : matte , 'M' : metallic 
	//see those as ordered sequence
	if (*buf != '\n')
	{
		if (pars_consumeMaterial(&mat.type, &buf)) 
			return (1);
		pars_skipWhiteSpace(&buf);
	}
	if (*buf != '\n')
		return (1);

	//check if consumed match logic
	if (!std_cmpDoubles(vec_vectorLen(&normalized_normal), 1) || pars_checkColorRange(color))
		return (1);
	
	//now I have validated plane parameters
	
	//we now fill
	shape_fillPlane(&shape, point, normalized_normal, color);
	//assumes material type has been added to mat
	pars_fillMaterial(&mat);
	obj_fillObj(obj, shape, mat, color);
	return (0);
}
// line is either a command or empty
// line is either a command or empty
int	pars_parseLine(t_parsables *parsables, char *buf, t_cmd_type *cmdtype)
{
	pars_skipWhiteSpace(&buf);

	//empty line -> exit with no err
	if (!(*buf))
		return (0);

	if (pars_consumeType(cmdtype, &buf))
		return (1);
	
	if (*cmdtype == SPHERE_CMD)
	{
		if (pars_parseSphere(&parsables->obj, buf))
			return (1);
	}
	else if (*cmdtype == AMBIENT_CMD)
	{
		if (pars_parseAmbient(&parsables->amb, buf))
			return (1);
	}
	else if (*cmdtype == CAMERA_CMD)
	{
		if (pars_parseCamera(&parsables->view, buf)) //NOT CAM
			return (1);
	}
	else if (*cmdtype == LIGHT_CMD)
	{
		if (pars_parseLight(&parsables->light, buf))
			return (1);
	}
	else if (*cmdtype == CYLINDER_CMD)
	{
		if (pars_parseCylinder(&parsables->obj, buf))
			return (1);
	}
	else if (*cmdtype == PLANE_CMD)
	{
		if (pars_parsePlane(&parsables->obj, buf))
			return (1);
	}
	else
		return (1);
	//TODO: missing plane and cyl
	return (0);
}

//has two modes : check duplicates mode (mode 0) and check basic setup (mode 1)
// on mode = 0 returns 1 if count light or camera or ambient > 1 and 0 otherwise
//on mode = 1 returns 1 if NOT COMPLETE. in mode1 , inputing type has no sense, you can thus write anything in the type field, For cleanness input "type = 0"
static int	pars_checkCounts(t_cmd_type type, int mode)
{
	static int	count_camera = 0;
	static int	count_light = 0;
	static int	count_ambient = 0;
	static int	count_obj = 0;

	if (type == CAMERA_CMD)
		count_camera++;
	else if (type == AMBIENT_CMD)
		count_ambient++;
	else if (type == LIGHT_CMD)
		count_light++;
	else if (type == SPHERE_CMD || type == PLANE_CMD || type == CYLINDER_CMD)
		count_obj++;
	
	//mode = 0 -> Check duplicates
	if (!mode)
	{
		if (count_light > 1 || count_camera > 1 || count_ambient > 1)
			return (1);
		return (0);
	}
	//mode == 1 -> Basic setup completeness check
	if (!count_light || !count_camera || !count_ambient || !count_obj)
		return (1);
	return (0);
	
}

static void	pars_setDefaultImg(t_scene *scene)
{
	double	img_ratio;
	double	img_width;

	img_ratio = 16.0 / 9.0;
	img_width = 900;
	img_fill(&scene->cam.img, img_width, img_ratio);
}

static int	pars_fillScene(t_scene *scene, t_parsables *parsables, t_cmd_type cmdtype)
{
	if (cmdtype == CAMERA_CMD)
	{
		pars_setDefaultImg(scene);
		cam_fillCam(&scene->cam, scene->cam.img, parsables->view);
	}
	else if (cmdtype == SPHERE_CMD || cmdtype == CYLINDER_CMD || cmdtype == PLANE_CMD)
		univ_addObj(&scene->univ, parsables->obj);
	else if (cmdtype == LIGHT_CMD)
		scene->light = parsables->light;
	else if (cmdtype == AMBIENT_CMD)
		scene -> ambient = parsables->amb;
	else
		return (1);
	return (0);
}

//TODO: REFACTOR IF YOU HAVE TIME responsibabilities are not clear : checking + filling + initialzing init + initializing img - All this in one fnuction
//FUNCTION INITIALIZES UNIV BEFORE STARTING THE PARSING
// Parses program and fills scene with all its field
#include <stdio.h> //TODO:REMOVE THIS
int	pars_parseProgram(int fd, t_scene *scene)
{
	t_parsables	parsables;
	char		*line;
	t_cmd_type	cmdtype;

	univ_init(&scene->univ);
	line = get_next_line(fd);
	while (line)
	{
		if (pars_parseLine(&parsables, line, &cmdtype))
		{
			free(line);
			return (1);
		}
		//checks if repeated light , cam or ambient
		if (pars_checkCounts(cmdtype, 0))
		{
			free(line);
			return (1);
		}
		if (pars_fillScene(scene, &parsables, cmdtype))
		{
			free(line);
			return (1);
		}
		free(line);
		line = get_next_line(fd);
	}
	free(line);
	//checks for there are at least 1 object, cam ,light, ambient
	if (pars_checkCounts(0, 1))
		return (1);
	return (0);
}
render.c 
#include "ui.h"
#include "stdlib.h"
# include "error.h"
#include "scene.h"
#include "lambertphong.h"

void	render_rayColor(t_vec *color, t_ray *ray, t_scene *scene)  //t_univ *univ, t_light *light)
{
	t_hitRec	rec;

	if (univ_hit(ray, &scene->univ, &rec)) //assumes tmin/max defined in throwray only
		lp_shade(color, &rec, ray, scene);
	else
		vec_fillVec(color, 0, 0, 0);
}

static void render_remLinesErrMsg(int remaining_lines)
{
	char	str[100];

	std_itoa(str, remaining_lines); 
	err_writeStdErr("Remaining lines ", 3, str, "\n");
}

static void render_drawpixel(ui_mlxParams_t *p, t_vec *pixel, int x, int y)
{
	int	red;
	int	green;
	int	blue;
	int	color;

	red = (int)(255.999 * pixel->x);
	green = (int)(255.999 * pixel->y);
	blue = (int)(255.999 * pixel->z);
	color = (red << 16) | (green << 8) | blue;
	*(unsigned int *)(p->buf + y * p->line_len + x * (p->bpp / 8)) = color;
}

//idea
//throw ray -> using x and y
//color pixel -> color(ray, world);
	// color(ray, world) : uses hit, uses list of objects
//then after finding the color of ray at (x,y):
//use ui_drawpixel (move it here as a static function) : takes mlx param, pixel color and x and y (all good)

static void	render_throwThenColor(ui_mlxParams_t *p, t_scene *scene, int pixel_i, int pixel_j) // t_cam *cam, t_univ *univ, int pixel_i, int pixel_j, t_light *light)
{
	t_ray	ray;
	t_vec	color;

	//get ray for (i,j)
	cam_throwRay(&ray, &scene->cam, pixel_i, pixel_j);
	//get color for the ray
	render_rayColor(&color, &ray, scene); // needs to be modified, here, its naive
	render_drawpixel(p, &color, pixel_i, pixel_j);
}

//render_throwThenColor needs refactoring
void	render_logicToMlx(ui_mlxParams_t *p, t_scene *scene) //t_cam *cam, t_univ *univ, t_light *light)
{
	int	y;
	int	x;
	int	height;
	int	width;

	height = scene->cam.img.img_height;
	width = scene->cam.img.img_width;
	y = 0;
	while (y < height)
	{
		render_remLinesErrMsg(height - y);
		x = 0;
		while (x < width)
		{
			render_throwThenColor(p, scene, x, y);//&scene->cam, &scene->univ, x, y, &scene->light);
			x ++;
		}
		y ++;
	}
	err_writeStdErr("Done\n", 1);
}

and here is the universe implementation:

#include "universe.h"
#include "ray.h"
#include "sphere.h"
#include "intersection.h"
#include <stdlib.h> //for exit(139) line 52
#include "stdlib.h"

#include "shape.h"

void	univ_init(t_univ *univ)
{
	univ->count = 0;
}

int	univ_addObj(t_univ *univ, t_obj obj)
{
	if (univ->count >= OBJLST_CAP)
		return (1);
	univ->obj_lst[(univ->count)++] = obj;
	return (0);
}

void	univ_pointLastObj(t_obj **obj, t_univ *univ)
{
	std_assert(univ->count > 0);

	*obj = &(univ->obj_lst[(univ->count) - 1]);
}

//fill rec with obj related properties (rec's other fields are filled)
static void	univ_fillRecObj(t_obj *obj, t_hitRec *rec)
{
	rec->color = obj->color;
	rec->shape = obj->shape.type;
	rec->mat = obj->mat.type;
}

static int	univ_obj_hit_and_rec(t_obj *obj, t_ray *ray, t_hitRec *rec, double tmin, double *tmax)
{
	if (!obj_hit(obj, ray, tmin, *tmax, rec))
		return (0);
	*tmax = rec->t;
	univ_fillRecObj(obj, rec);
	return (1);
}

static int	univ_iterate_hits(t_ray *ray, t_univ *univ, t_hitRec *rec, double tmin, double *tmax)
{
	int	i;
	int	hit;

	i = 0;
	hit = 0;
	while (i < univ->count)
	{
		if (univ_obj_hit_and_rec(&univ->obj_lst[i], ray, rec, tmin, tmax))
			hit = 1;
		i++;
	}
	return (hit);
}

int	univ_hit(t_ray *ray, t_univ *univ, t_hitRec *rec)
{
	double	tmin;
	double	tmax;

	tmin = 0.001;
	tmax = 1e6;
	return (univ_iterate_hits(ray, univ, rec, tmin, &tmax));
}

and here is the object implementation

#include "object.h"

void	obj_fillObj(t_obj *obj, t_shape shape, t_mat mat, t_vec color)
{
	obj->shape = shape;
	obj->mat = mat;
	obj->color = color;
}

int	obj_hit(t_obj *obj, t_ray *ray, double t_min, double t_max, t_hitRec *rec)
{
	return (shape_hit(&obj->shape, ray, t_min, t_max, rec));
}

and hereis the shape implementation
#include "shape.h"
#include "vector.h"
#include "sphere.h"
#include "plane.h"

void	shape_fillSphere(t_shape *shape, t_vec center, double radius)
{
	shape->type = SPHERE_TYPE;
	sph_fillSph(&shape->as.sphere, center, radius);
}

void	shape_fillPlane(t_shape *shape, t_vec point, t_vec normalized_normal, t_vec color)
{
	shape->type = PLANE_TYPE;
	plane_fillPlane(&shape->as.plane, point, normalized_normal, color);
}

void	shape_fillCylinder(t_shape *shape, t_vec center, t_vec normalized_axis, t_vec color, double diameter, double height)
{
	shape->type = CYLINDER_TYPE;
	cyl_fillCyl(&shape->as.cylinder, center, normalized_axis, color, diameter, height);
}

int	shape_hit(t_shape *shape, t_ray *ray, double t_min, double t_max, t_hitRec *rec)
{
	if (shape->type == SPHERE_TYPE)
		return (sph_hit(&shape->as.sphere, ray, t_min, t_max, rec)); 

	if (shape->type == PLANE_TYPE)
		return (plane_hit(ray, &shape->as.plane, t_min, t_max, rec));  //TODO: swap the order of ray and plane parameters to make it consistent with other hit funcions
	
	if (shape->type == CYLINDER_TYPE)
		return (cyl_hit(&shape->as.cylinder,ray,  t_min, t_max, rec)); 

	return (0);
}


and here is the sphere implementation

#include "sphere.h"
#include "ray.h"
#include "stdlib.h"
#include <math.h>
#include "intersection.h"
# include "vector.h"

typedef struct s_sph_quadParams
{
	double	a;
	double	h;
	double	c;
	double	delta;
}	t_sph_quadParams;


void	sph_fillSph(t_sph *sphere, t_vec center, double radius)
{
	sphere->obj_type = 's';
	sphere->center = center;
	sphere->radius = radius;
}

static void	sph_solveQuadratic(t_sph_quadParams *params, t_sph *sphere, t_ray *ray)
{
	t_vec	oc;

	vec_subs(&oc, &sphere->center, &ray->orig);
	params->a = vec_squaredLen(&ray->dir);
	params->h = vec_dot(&ray->dir, &oc);
	params->c = vec_squaredLen(&oc) - sphere->radius * sphere->radius;
	params->delta = (params->h * params->h - params->a * params->c);
}

//ray can start inside the sphere -> normal can point inside the sphere. This function checks and solves this issue
static	void	sph_normalPointOut(t_vec *normal, t_ray *ray)
{
	if (vec_dot(normal, &ray->dir) > 0)
		vec_scale(normal, -1, normal);
}

int	sph_hit(t_sph *sphere, t_ray *ray, double t_min, double t_max, t_hitRec *rec)
{
	//asserts e.g. rec not null...
	t_sph_quadParams	params;
	t_vec	normal_non_unit;
	double	sqrtd;
	double	root;

	sph_solveQuadratic(&params, sphere, ray);
	if (params.delta < 0)
		return (0);
	sqrtd = sqrt(params.delta);
	root = (params.h - sqrtd) / params.a;
	if (root <= t_min || root >= t_max)
	{
		root = (params.h + sqrtd) / params.a;
		if (root <= t_min || root >= t_max)
			return (0);
	}
	rec->t = root;
	ray_at(&rec->p, ray, root);
	vec_subs(&normal_non_unit, &rec->p, &sphere->center);
	vec_scale(&rec->normal, 1.0 / sphere->radius, &normal_non_unit);
	sph_normalPointOut(&rec->normal, ray);
	return (1);
}


and here are some interfaces I rely on 
#ifndef AMBIENTLIGHT_H
#define AMBIENTLIGHT_H
# include "vector.h"

typedef struct s_ambientLight
{
	double ratio;
	t_vec	color;
}	t_ambientLight;

void	al_fill(t_ambientLight *amb_light, double ratio, t_vec color);

#endif
//camera module refers to everything set by camera : camera location, viewport, ortho basis.
#ifndef CAMERA_H
#define CAMERA_H

# include "vector.h"
# include "ray.h"
# include "sphere.h" // remove when cam_rayCOlor is moved
# include "universe.h"// remove when cam_rayCOlor is moved
# include "light.h"// remove when cam_rayCOlor is moved
# include "viewer.h"
# include "image.h"

typedef	struct s_geom
{
	//not normalized
	t_vec	lookat_to_lookfrom;

	t_vec	orthobasis_w;
	t_vec	orthobasis_u;
	t_vec	orthobasis_v;

	double	focal_dist;

	double	screen_height; 
	double	screen_width;

	t_vec	screen_u;
	t_vec	screen_v;

	t_vec	screen00_loc;

	t_vec	pix00_loc;

	t_vec	pix_delta_u;
	t_vec	pix_delta_v;
}	t_geom;

typedef struct s_cam
{
	t_img	img;
	t_viewer view;
	t_geom	geom;
}	t_cam;

//assumes img and view are already filled. Dot not pass undefined view and img
void	cam_fillCam(t_cam *cam, t_img img, t_viewer view);

void	cam_throwRay(t_ray *ray, t_cam *cam, int pixel_i, int pixel_j);
#endif
#ifndef CYLINDER_H
# define CYLINDER_H

#include "intersection.h"
#include "ray.h"

typedef struct s_cylinder
{
	t_vec	center;
	t_vec	normalized_axis;
	t_vec	color;
	double	diameter;
	double 	radius;
	double	height;
}	t_cylinder;

void	cyl_fillCyl(t_cylinder *cyl, t_vec center, t_vec normalized_axis, t_vec color, double diameter, double height);

//returns bool AND if hit fills hitRec
//Refer to my note on line cylinder intersection to understand logic
int	cyl_hit(t_cylinder *cyl, t_ray *ray, double t_min, double t_max, t_hitRec *rec);

#endif
#ifndef ERROR_H
#define ERROR_H

int	err_msgReturnOne(const char *err_msg);

void	err_writeStdErr(const char *first_err_msg, int n_msg, ...); //contract ???e.g. n = 4 but no variadic params-> trash

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jissa <jissa@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/05 14:50:31 by jissa             #+#    #+#             */
/*   Updated: 2025/06/10 16:38:08 by jissa            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
//TODO: refactor - most accessible to user - api like
#ifndef GET_NEXT_LINE_H
# define GET_NEXT_LINE_H

# ifndef BUFFER_SIZE
#  define BUFFER_SIZE 42
# endif

# include <unistd.h>
# include <stdio.h>
# include <fcntl.h>
# include <stdlib.h>

char	*ft_strjoin(char const *s1, char const *s2);
char	*ft_strchr(const char *s, int c);
char	*ft_substr(const char *s, unsigned int start, size_t len);
char	*ft_strdup(const char *s);
size_t	ft_strlen(const char *str);

// MY CHANGE TO JISSA'S Gnl - all of it needs refactoring
char	*get_next_line(int fd);	
#endif
#ifndef IMAGE_H
# define IMAGE_H

typedef	struct	s_img
{
	int	img_width;
	int	img_height;
	double	img_ratio;
}	t_img;

void	img_fill(t_img *img, int img_width, double img_ratio);

#endif
#ifndef INTERSECTION_H
#define INTERSECTION_H

#include "vector.h"
#include "material.h"

typedef struct s_hitRec { //seperate it  (other module - intersection != object definition)
	t_vec	p;
	t_vec	normal;
	t_vec	color;
	int	shape;
	int	mat;
	double	t;
}	t_hitRec;

#endif
#ifndef LAMBERTPHONG_H
#define LAMBERTPHONG_H
# include "ray.h"
# include "intersection.h"
# include "universe.h"
# include "scene.h"

//naive needs change
int	lp_attenuationFactor(t_ray *ray_to_light, t_univ *univ);

//all directions should be normalized
void	lp_shade(t_vec *color, t_hitRec *rec, t_ray *ray, t_scene *scene);
#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jissa <jissa@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/24 17:57:49 by jissa             #+#    #+#             */
/*   Updated: 2025/05/28 12:19:19 by jissa            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H

# include <unistd.h>
# include <stdlib.h>
# include <stdio.h>

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}	t_list;

int		ft_isalpha(int c);
int		ft_isdigit(int c);
int		ft_isalnum(int c);
int		ft_isascii(int c);
int		ft_isprint(int c);
size_t	ft_strlen(const char *s);
void	*ft_memset(void *b, int c, size_t len);
void	ft_bzero(void *s, size_t n);
void	*ft_memcpy(void *dst, const void *src, size_t n);
void	*ft_memmove(void *dst, const void *src, size_t len);
size_t	ft_strlcpy(char *dst, const char *src, size_t dstsize);
size_t	ft_strlcat(char *dst, const char *src, size_t dstsize);
int		ft_toupper(int c);
int		ft_tolower(int c);
char	*ft_strchr(const char *s, int c);
char	*ft_strrchr(const char *s, int c);
int		ft_strncmp(const char *s1, const char *s2, size_t n);
void	*ft_memchr(const void *s, int c, size_t n);
int		ft_memcmp(const void *s1, const void *s2, size_t n);
char	*ft_strnstr(const char *haystack, const char *needle, size_t len);
int		ft_atoi(const char *str);
void	*ft_calloc(size_t count, size_t size);
char	*ft_strdup(const char *s1);
char	*ft_substr(char const *s, unsigned int start, size_t len);
char	*ft_strjoin(char const *s1, char const *s2);
char	*ft_strtrim(char const *s1, char const *set);
char	**ft_split(char const *s, char c);
char	*ft_itoa(int n);
char	*ft_strmapi(char const *s, char (*f)(unsigned int, char));
void	ft_striteri(char *s, void (*f)(unsigned int, char *));
void	ft_putchar_fd(char c, int fd);
void	ft_putstr_fd(char *s, int fd);
void	ft_putendl_fd(char *s, int fd);
void	ft_putnbr_fd(int n, int fd);
t_list	*ft_lstnew(void *content);
void	ft_lstadd_front(t_list **lst, t_list *new);
int		ft_lstsize(t_list *lst);
t_list	*ft_lstlast(t_list *lst);

#endif
#ifndef LIGHT_H
# define LIGHT_H
# include "vector.h"
# include "ray.h"

typedef struct s_light
{
	t_vec	src;
	t_vec	color;
	double	bright;
}	t_light;

void	light_fill(t_light *light, t_vec src, t_vec color, double brightness);

//normalized
void	light_rayToLight(t_ray	*ray, t_vec *point, t_vec *light_src);

#endif
#ifndef MANAGEMATERIALS_H
#define MANAGEMATERIALS_H
#define MNGMAT_MAX 100

#include "material.h"

typedef struct s_material_list
{
	//data represent the list of materials (called "data" for naming coherence)
	t_mat	data[MNGMAT_MAX];
	int		count;
}	t_material_list;

//point to last available material in list and count ++. returns (1) on err (above max number of material). 0 otherwise
int	mngmat_new_material(t_mat **material, t_material_list *list);

//point to material i in list
void	mngmat_access_material_i(t_mat **material, t_material_list *list, int i);


#endif
//TODO: MANAGE FOR COUNT > CAPACITY
#ifndef MANAGESPHERES_H
#define MANAGESPHERES_H

#define MNGSPH_MAX 100

#include "sphere.h"

typedef struct s_sphere_list
{
	//data represent the list of spheres (called "data" for naming coherence)
	t_sph	data[MNGSPH_MAX];
	int		count;
}	t_sphere_list;

//point to last available sphere in list and count ++.return (1) on err (more than available spheres)
int	mngsph_new_sphere(t_sph **sphere, t_sphere_list *list);

//point to sphere i in list
void	mngsph_access_sphere_i(t_sph **sphere, t_sphere_list *list, int i);


#endif
#ifndef MATERIAL_H
#define MATERIAL_H

#include "matte.h"

typedef enum
{
	MATTE_TYPE
	//METALLIC_TYPE;
	//GLASS_TYPE;
}	material_type;


typedef struct s_material
{
	material_type type;
	union
	{
		t_matte matte;
		//t_met metallic;
		//t_gl  glass;
	} as;
}	t_mat;

void	mat_fillMatte(t_mat *mat, int onoff);

#endif
#ifndef MATTE_H
#define MATTE_H

typedef struct s_matte
{
	int	onoff; //This has no purpose, its just a placeholder. I can replace it with roughness of material, But keep it like this, until code is well handled
}	t_matte;

void	matte_fillMatte(t_matte *matte, int onoff);
#endif
#ifndef OBJECT_H
#define OBJECT_H

#include "vector.h"
#include "material.h"
#include "shape.h"

typedef struct s_hitRec t_hitRec;

typedef struct s_obj
{
	t_shape		shape;
	t_mat		mat;
	t_vec		color;
}	t_obj;

void	obj_fillObj(t_obj *obj, t_shape shape, t_mat mat, t_vec color);

int	obj_hit(t_obj *obj, t_ray *ray, double t_min, double t_max, t_hitRec *rec);

#endif



/*
t_shape shape;
t_mat   mat;
t_obj   obj;

shape_fillSphere(&shape, center, radius);
mat_fillMatte(&mat, onoff);
obj_fillObj(&obj, shape, mat, color);
*/
//TODO: riaseError() uses io (write !). how can I delegate this to client
//TODO:  PARSE LIGHT () SHOULD FILL T_LIGHT THIS IS WRONG
//TODO:  Change name of consumeNumber and Comma to parse (i.e. raises err too)
//TODO:  Make it explicit that some of the parsers (e.g. parse light and camera ...) do take into consideration whitespace OR REMOVE THE WHITESPACE AND DELEGATE IT TO PARSELINE
//TODO:  Assumes default image parametr which influences the viewport !! take this into consideration
#ifndef PARSER_H
# define PARSER_H
# include "vector.h"
# include "light.h"
# include "ambientlight.h"
# include "viewer.h"
# include "object.h"
# include "sphere.h"
# include "material.h"
# include "scene.h"

// these are the fields that user can fill through .rt
// they generalize to t_scene
typedef struct s_parsables
{
	t_light light;
	t_ambientLight	amb;
	t_viewer	view;
	t_obj	obj;
}	t_parsables;

typedef enum
{
	CAMERA_CMD,
	LIGHT_CMD,
	AMBIENT_CMD,
	SPHERE_CMD,
	CYLINDER_CMD,
	PLANE_CMD, //NOTE: cyl and plane already implemented here
}	t_cmd_type;

void	pars_skipWhiteSpace(char **ptr_buf);

//STRICT CONTRACT: PTR_BUF MUST BE NUL TERMINATED
//type is case sensitive : 'c' : cylinder != 'C' : camera
//assumes no whitespace, consumes and advances the type
int	pars_consumeType(t_cmd_type *type, char **ptr_buf);

//assumes no whitespaces. Consume number and advances. double parsing relies on atod, returns 1 on err
int	pars_consumeNumber(double *num, char **buf);

//assumes no whitespaces. Consume int and advances. int parsing relies on atoi, returns 1 on err
int	pars_consumeInteger(int *num, char **buf);

//No whitespace assumptoin. consume comma. If no comma return (1) (parsin err)
int	pars_consumeComma(char **buf);

//assumes comma seperation between them, allows for whitespace between numbers
int	pars_consume3Numbers(t_vec *vector, char **buf);

int	pars_consume3Integers(t_vec *vector, char **buf);

int	pars_consumeMandatoryWhiteSpace(char **buf);

int	pars_checkColorRange(t_vec color);

int	pars_checkUnitIntervalRange(double num);

int	pars_parseLight(t_light *light, char *buf);

int	pars_parseAmbient(t_ambientLight *ambient, char *buf);

int	pars_parseCamera(t_viewer *view, char *buf);

int	pars_parseSphere(t_obj *obj, char *buf);

int	pars_parseCylinder(t_obj *obj, char *buf);

int	pars_parsePlane(t_obj *obj, char *buf);

int	pars_parseProgram(int fd, t_scene *scene);
#endif
#ifndef PLANE_H
# define PLANE_H

#include "intersection.h"
#include "vector.h"
#include "ray.h"

typedef struct s_plane
{
	t_vec	point;
	t_vec	normalized_normal;
	t_vec	color;
}	t_plane;

void	plane_fillPlane(t_plane *plane, t_vec point, t_vec normalized_normal, t_vec color);

//returns bool AND if hit fills hitRec
int	plane_hit(t_ray *ray, t_plane *t_plane, double t_min, double t_max, t_hitRec *rec);
#endif
#ifndef PROGRAMPARAMS_H
#define PROGRAMPARAMS_H

#include "light.h"
#include "cam.h"
#include "ambient.h"
#include "managematerials.h"
#include "managespheres.h"

typedef struct s_rt_params
{
	t_light	light;
	t_cam	cam;
	t_ambientLight ambient;
	t_material_list material;
	t_sphere_list sphere;
	t_obj_list obj; // should be t_univ ?? 
	// still  need to add cylinder and plane and different materials
}	t_rt_params;

#endif
#ifndef RAY_H
# define RAY_H
# include "vector.h"

typedef struct s_ray
{
	t_vec	dir;
	t_vec	orig;
}	t_ray;

void	ray_at(t_vec *res, t_ray *ray, double t);

void	ray_fillRay(t_ray *ray, t_vec orig, t_vec dir);

//if there is time build a string len function - like in vector.h
//string should be big enough
void	ray_toStr(char	*string, t_ray *ray, int precision);
#endif
#ifndef RENDER_H
#define RENDER_H

# include "ui.h"
# include "scene.h"

void	render_logicToMlx(ui_mlxParams_t *params, t_scene *scene);

//sould be in render!!!
//temporary function - needs modif

void	render_rayColor(t_vec *color, t_ray *ray, t_scene *scene);
#endif
#ifndef SCENE_H
#define SCENE_H

#include "camera.h"
#include "universe.h"
#include "light.h"
#include "ambientlight.h"

//univ refers to the "universe of objects"
typedef struct s_scene
{
	t_cam		cam;
	t_univ		univ;
	t_light		light;
	t_ambientLight ambient;
}	t_scene;
	
#endif
#ifndef SHAPE_H
#define SHAPE_H

#include "vector.h"
#include "sphere.h"
#include "cylinder.h"
#include "plane.h"

typedef struct s_hitRec t_hitRec;

typedef enum
{
	SPHERE_TYPE,
	CYLINDER_TYPE,
	PLANE_TYPE,
}	shape_type;

typedef struct s_shape
{
	shape_type	type;
	union
	{
		t_sph sphere;
		t_cylinder cylinder;
		t_plane plane;
	} as;
}	t_shape;

void	shape_fillSphere(t_shape *shape, t_vec center, double radius);
void	shape_fillPlane(t_shape *shape, t_vec point, t_vec normalized_normal, t_vec color);
void	shape_fillCylinder(t_shape *shape, t_vec center, t_vec normalized_axis, t_vec color, double diameter, double height);


int	shape_hit(t_shape *shape, t_ray *ray, double t_min, double t_max, t_hitRec *rec);

#endif
//TODO:should remove obj_type from sphere ultimately
#ifndef SPHERE_H
#define SPHERE_H

#include "ray.h"
#include "intersection.h"

typedef struct s_sphere
{
	int	obj_type;
	t_vec   center;
	double  radius;
}	t_sph;

void	sph_fillSph(t_sph *sphere, t_vec center, double radius);

//returns bool AND if hit fills hitRec
int	sph_hit(t_sph *sphere, t_ray *ray, double t_min, double t_max, t_hitRec *rec);

#endif
#ifndef STDLIB_H
#define STDLIB_H

int	std_pow(int base, int power);

void	std_assert(int condition);

int	std_strlen(const char *string);

int	std_cmpDouble(double double1, double double2, double epsilon);

/*arr points at at least std_sizeArray(int number) bytes*/
int	std_sizeArray(int int_from_which_you_form_array);
void	std_itoa(char *array, int number);

/*arr points at at least std_sizeArrayDouble(int number, precision) bytes*/
int	std_sizeArrayDouble(double double_from_which_you_form_array, int precision);
void	std_dtoa(char *arr, double n, int precision);

void	std_fillThenNull(char *arr, char c);

int	std_strlcpy(char *dst, const char *src, int size);

int	std_isWhiteSpace(char c);

int	std_isNum(char c);

// returns num1 == num2 assuming a 1e-6 epsilon
int	std_cmpDoubles(double num1, double num2);

//no whitespace skipping, expects +number -number only. returns nbytes consumed if return = 0 ->(err, no bytes consumed)
///e.g. "+12.12.12" , out becomes 12.12 return is 5 
///e.g. "+12." , out becomes 12 return is 3 ('+' '1' '2' are consumed) 
//"12." returns 2 and out of 12       ".12" returns 0 .                         "--12" returns 0 
int	std_atod(double *out, char *buf);

//same rules as before but for int
//"12.12" -> out is 12 return is 2
int	std_atoi(int *out, char *buf);
#endif
#ifndef UI_H
#define UI_H

typedef struct ui_mlxParams_s
{
	void	*mlx;
	void	*win;
	void	*img;
	char	*buf;
	int	bpp;
	int	line_len;
	int	endian;
	int	width;
	int	height;
}	ui_mlxParams_t;

//basic mlx parameter initilization
int	ui_initMlx(ui_mlxParams_t *params, double aspectRatio, int width, char *title);

void	ui_buildImg(ui_mlxParams_t* params);

//let mlx display after filling its pixel buf
void	ui_mlxRender(ui_mlxParams_t *params);
#endif










/*
int main(void)
{
	ui_mlxParams_t mlx_params;

	if (ui_initMlx(&mlx_params, 256, 256, "MiniRT"))
        	return err_msgReturnOne("MLX init failed");
	ui_buildImg(&mlx_params);
	ui_mlxRender(&mlx_params);
}
*/
#ifndef UNIVERSE_H
#define UNIVERSE_H

#include "object.h"
#include "ray.h"

#define OBJLST_CAP 100

typedef struct s_hitRec t_hitRec;

typedef struct s_univ
{
	t_obj	obj_lst[OBJLST_CAP];
	int	count;
}	t_univ;

//mandatory initialization - sets count to 0
void	univ_init(t_univ *univ);

//adds obj to univ at last index - returns 1 on err (exceeded capacity)
int	univ_addObj(t_univ *univ, t_obj obj);

//point to last added obj
void	univ_pointLastObj(t_obj **obj, t_univ *univ);

//FUNCTION HERE HAS TWO ROLES
//returns 1 if hit 0 otherwise. Fills Record if hit
int	univ_hit(t_ray *ray, t_univ *univ, t_hitRec *rec);
//does it make sense to have rec as input here -> review where exactly is rec used. see render

#endif
#ifndef VECTOR_H
#define VECTOR_H

typedef struct vector_s
{
	double	x;
	double	y;
	double	z;
}	t_vec;

void	vec_centerVec(t_vec *vec);

void	vec_fillVec(t_vec *vec, double x, double y, double z);

//vec1 - vec2
void	vec_subs(t_vec *result, t_vec *vec1, t_vec *vec2);

void	vec_add(t_vec *result, t_vec *vec1, t_vec *vec2);

void	vec_scale(t_vec *result, double factor, t_vec *vec);

double	vec_squaredLen(t_vec *v);

double	vec_vectorLen(t_vec *v);

void	vec_unitVector(t_vec *res, t_vec *v);

void	vec_cross(t_vec *result, t_vec *v1, t_vec *v2);

double	vec_dot(t_vec *v1, t_vec *v2);

/*string should be at least vec_strLen(t_vec, int) bytes*/
int	vec_strLen(t_vec *vector, int precision);
void	vec_toStr(char *string, t_vec *vector, int precision);

void	vec_componentWiseMultiplication(t_vec *result, t_vec *v1, t_vec *v2);

#endif
#ifndef VIEWER_H
# define VIEWER_H
# include "vector.h"

typedef struct s_viewer
{
	t_vec	lookfrom;
	t_vec	lookat;
	t_vec	vup; //vector that defines x and y on plane orth. to lookat dir
	double	hfov;
}	t_viewer;

void	viewer_fill(t_viewer *viewer, t_vec vup, t_vec lookfrom, t_vec lookat, double hfov);

//fill viewer under default parameters
// TAKES ORIENTATION VECTOR AS PARAMETER AND FINDS LOOKAT FROM IT
void	viewer_defaultFill(t_viewer *viewer, t_vec lookfrom, double hfov, t_vec orientation_vector);
#endif
