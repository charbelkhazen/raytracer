// PROMPT IS NOT DONE - IT IS TOO COMPLEX TO WRITE


I wrote different parsing functions following a single interface (set of functions) and a similar rationale for every function

I would like you to help me write other parsing functions using the same interface and same logic

before, let me present you crucial background information

here is my interface (API) for building the parsing functions


#ifndef PARSER_H
# define PARSER_H
# include "vector.h"
# include "light.h"
# include "ambientlight.h"
# include "viewer.h"
# include "object.h"
# include "sphere.h"
# include "material.h"

void	pars_skipWhiteSpace(char **ptr_buf);

//consumes and returns type as int (which corresponds to first char of of type)
int	pars_consumeType(char **ptr_buf);

//assumes no whitespaces. Consume number and advances. double parsing relies on atod, returns 1 on err
int	pars_consumeNumber(double *num, char **buf);

//assumes no whitespaces. Consume int and advances. int parsing relies on atoi, returns 1 on err
int	pars_consumeInteger(int *num, char **buf);

//No whitespace assumptoin. consume comma. If no comma return (1) (parsin err)
int	pars_consumeComma(char **buf);

//assumes comma seperation between them, allows for whitespace between numbers
int	pars_consume3Numbers(t_vec *vector, char **buf);

int	pars_consume3Integers(t_vec *vector, char **buf);

int	pars_consumeMandatoryWhiteSpace(char **buf);

int	pars_checkColorRange(t_vec color);

int	pars_checkUnitIntervalRange(double num);

#endif



here is the rationale of a parsing function and its implementation

parsing rationale for a sphere parser:
first three numbers are doubles which are comma seperated (i.e. first and second and second and third are comma seperated) and for which one or more spaces are allowed after first and second number and first and second comma
then followed by one or more mandatory spaces 
then followed by a double 
followed by one or more mandatory spaces
followed by  three integers which are comma seperated (i.e. first and second and second and third are comma seperated) and for which one or more spaces are allowed after first and second integers and first and second comma
note: the three integers should all be between 0-255
then followed by an optional character which represents the material type

implementation:

int	pars_parseSphere(t_obj *obj, t_sph *sphere, t_mat *material, char *buf)
{
	t_vec	center;
	t_vec	color;
	double	diameter;
	int	mat_type;

	std_assert(buf != 0);

	//default material is matte, if user inputs another then change (simulate default arg)
	mat_type = 'm';

	//parsing and consuming
	pars_skipWhiteSpace(&buf);
	// see those as ordered steps in parsing. and if a step fails -> returns (1) -> func returns (1). I wrote it in one line for compactness
	if (pars_consume3Numbers(&center, &buf) || pars_consumeMandatoryWhiteSpace(&buf) 
		|| pars_consumeNumber(&diameter, &buf) || pars_consumeMandatoryWhiteSpace(&buf)
		|| pars_consume3Integers(&color, &buf))
		return (1);
	pars_skipWhiteSpace(&buf);
	//optional material : 'm' : matte , 'M' : metallic 
	//see those as ordered sequence
	if(*buf)
	{
		if (pars_consumeMaterial(&mat_type, &buf)) 
			return (1);
		pars_skipWhiteSpace(&buf);
	}
	if(*buf)
		return (1);

	//check if consumed match logic
	if (pars_checkColorRange(color) || diameter < 0)
		return (1);

	sph_fillSph(sphere, center, diameter / 2.0);
	mat_fillMaterial(material, mat_type, color);
	obj_fillObj(obj, 's', (void *)sphere, mat_type, (void*)material);

	return (0);
}


it is important to note that a sphere like a cylinder or a plane are objects 

and refer to the following structure


typedef struct s_obj {
	int	obj_shapeType;
	void	*obj_shape;
	int	obj_matType;
	void	*obj_mat;
}	t_obj;


such that obj_shape refer to different shapes 

typedef struct s_sphere
{
	int	obj_type;
	t_vec   center;
	double  radius;
}	t_sph;

and such that obj_mat refers to 

typedef struct s_material
{
	char	type; // why  not int
	t_vec	color;
}	t_mat;



for now obj_mat will always refer to this struct, later on obj_mat will refer to different ypes of struct .... lets'




you will need to assume a struct for t_cylinder and t_plane



.........................
